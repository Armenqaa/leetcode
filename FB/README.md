# FaceBook


#1 MonotonicArray(https://leetcode.com/problems/monotonic-array/): 
Вернуть true тогда и только тогда, когда данный массив A монотонен(<= || >=). В противном случае вернуть false.


#2 MinimumAddToMakeParenthesesValid(https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/):
Дана строка s, состоящая из скобок '(' и ')', мы добавляем минимальное количество скобок '(' или ')' в любых позициях, чтобы полученная строка скобок была верной.


#3 GroupsOfSpecial-EquivalentStrings(https://leetcode.com/problems/groups-of-special-equivalent-strings/):
Вам дан массив строк A. Две строки S и T специально эквивалентны, если после любого количества замен S == T.
Замена состоит из выбора двух индексов i и j, что i% 2 == j% 2 и замены S[i] на S[j]. 
Группа специально эквивалентных строк из A - это непустое подмножество S из A, такое, что любая строка, не входящая в S,
не является специально эквивалентной ни одной строке из S. Верните количество групп, что в каждой группе строки специально эквивалентны.


#4 SingleNumber(https://leetcode.com/problems/single-number):
Дан непустой массив целых чисел nums, каждый элемент повторяется дважды, кроме одного. Найдите его.


#5 BackspaceStringCompare(https://leetcode.com/problems/backspace-string-compare/): 
Даны две строки s и t, верните true, если они равны, когда обе введены в пустые текстовые редакторы, где '#' означает удаление предыдущего символа(Backspace).


#6 FindAllDuplicatesInAnArray(https://leetcode.com/problems/find-all-duplicates-in-an-array/):
Дан целочисленный массив nums длины n, где все целые числа nums находятся в диапазоне [1, n], и каждое целое число встречается один или два раза, 
верните массив всех целых чисел, который встречается дважды.


#7 FindAllNumbersDisappearedInAnArray(https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/):
Дан массив nums из n целых чисел, где nums[i] находится в диапазоне [1, n], 
вернуть массив всех целых чисел в диапазоне [1, n], которые не входят в nums.


#8 RemoveDuplicatesFromSortedList(https://leetcode.com/problems/remove-duplicates-from-sorted-list/):
Дан заголовок отсортированного связанного списка, удалите все дубликаты, чтобы каждый элемент отображался только один раз.
Вернуть также отсортированный связанный список.


#9 FindSmallestLetterGreaterThanTarget(https://leetcode.com/problems/find-smallest-letter-greater-than-target/):
Дан массив символов, которые отсортированы в неубывающем порядке, и таргет символ, вернуть наименьший символ в массиве, который больше таргета.


#10 AverageOfLevelsInBinaryTree(https://leetcode.com/problems/average-of-levels-in-binary-tree/):
Дан корень двоичного дерева, вернуть среднее значение узлов на каждом уровне в виде массива. Будут приняты ответы в пределах 10-5 от фактического ответа.


#11 MinimumDepthOfBinaryTree(https://leetcode.com/problems/minimum-depth-of-binary-tree/):
Для двоичного дерева найдите его минимальную глубину. Минимальная глубина - это количество узлов на кратчайшем пути от корневого узла до ближайшего листового узла.


#12 PathSum(https://leetcode.com/problems/path-sum/):
Дан корень двоичного дерева и целое число targetSum, верните true, если дерево имеет путь от корня к листу, так что сложение всех значений вдоль пути равно targetSum.


#13 SameTree(https://leetcode.com/problems/same-tree/submissions/):
Даны корни двух двоичных деревьев p и q, напишите функцию, чтобы проверить, совпадают ли они. 
Два бинарных дерева считаются одинаковыми, если они структурно идентичны, а узлы имеют одинаковые значения.


#14 DiameterOfBinaryTree(https://leetcode.com/problems/diameter-of-binary-tree/):
Дан корень двоичного дерева, верните длину диаметра дерева. 
Диаметр двоичного дерева - это длина самого длинного пути между любыми двумя узлами в дереве. 
Этот путь может проходить или не проходить через корень. Длина пути между двумя узлами является количеством ребер между ними.
